<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>卡诺图和QM算法（非教程向） | 工业区的后宅</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://firemakerwillow.github.io/favicon.ico?v=1614923181547">
<link rel="stylesheet" href="https://firemakerwillow.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="卡诺图化简法与Q-M化简法，我想了一周时间，还是没有比教材更好，更精简的讲法，所有的该奶奶都是必要的，所有的步骤都是必要的，环环相扣，不可或缺，既然如此，不如直接看教材好了，这里权作为笔记。
1. 布尔函数的化简
布尔代数可以用于描述组合逻..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://firemakerwillow.github.io">
        <img src="https://firemakerwillow.github.io/images/avatar.png?v=1614923181547" class="site-logo">
        <h1 class="site-title">工业区的后宅</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      一代人终将老去，但总有人永远年轻
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://firemakerwillow.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">卡诺图和QM算法（非教程向）</h2>
            <div class="post-date">2021-03-05</div>
            
            <div class="post-content" v-pre>
              <p>卡诺图化简法与Q-M化简法，我想了一周时间，还是没有比教材更好，更精简的讲法，所有的该奶奶都是必要的，所有的步骤都是必要的，环环相扣，不可或缺，既然如此，不如直接看教材好了，这里权作为笔记。</p>
<h2 id="1-布尔函数的化简">1. 布尔函数的化简</h2>
<p>布尔代数可以用于描述组合逻辑的函数关系。组合逻辑是指一个无记忆的系统，我们向这个系统中输入一些值，立即可以得到一些输出。比如说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>p</mi><mo separator="true">⋅</mo><mi>s</mi><mo>+</mo><mi>q</mi><mo separator="true">⋅</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">y=p·s+q·s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span></span></span></span>, 我们向系统中输入p, q, s 就可以得到输出y。</p>
<p>上面就是一个布尔函数的表达式，这个表达式是最简的吗？并不是，它可以变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mo>(</mo><mi>p</mi><mo>+</mo><mi>q</mi><mo>)</mo><mo separator="true">⋅</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">y=(p+q)·s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span></span></span></span> 这个式子只需要两步计算，而上面的式子需要3步。</p>
<p>由于我们的组合逻辑电路是用晶体管实现的，我们当然希望计算步骤越少越好，越少，我们需要的晶体管就越少，电路的性能就会更优越。</p>
<p>这时我们就需要一个程序性的，可以解决所有组合逻辑电路的布尔函数化简方法。</p>
<h2 id="2-卡诺图法和q-m法">2. 卡诺图法和Q-M法</h2>
<p>这是两个化简的方法，我们将通过一个例子来说明这两种方法。</p>
<h3 id="21-卡诺图法">2.1 卡诺图法</h3>
<table>
<thead>
<tr>
<th>CD\AB</th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>01</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>2.1.1 卡诺图法首先要列出一个真值表，这里列出了四变量真值表的列法</p>
<p>如果是三变量，是以下形式</p>
<table>
<thead>
<tr>
<th>C\AB</th>
<th>00</th>
<th>01</th>
<th>11</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>如果是二变量</p>
<table>
<thead>
<tr>
<th>B\A</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>四变量以上卡诺图是可以解决的，但不建议使用，最好使用后面要介绍的Q-M法</p>
<p>我们还回到4变量的例子。</p>
<p>卡诺图的列法中唯一需要注意的点是AB 或CD值的连续变化，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>00</mn><mo>→</mo><mn>01</mn><mo>→</mo><mn>11</mn><mo>→</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">00\rightarrow 01\rightarrow11\rightarrow10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 相邻两值之间仅有一位发生变化。</p>
<p>2.1.2 接下来我们要根据卡诺图写表达式，要用最大的矩形把所有的1项包围起来。</p>
<p>目标就是用最大最少的方框把所有的1都括起来，这时候，就有一些框是必不可少的，我们优先先把他们括起来，其他的再想办法，通过这种方法我们就能实现布尔函数的化简</p>
<h3 id="22-qm算法">2.2 QM算法</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo>)</mo><mo>=</mo><mo>∑</mo><mi>m</mi><mo>(</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo>)</mo><mo>+</mo><mi>d</mi><mo>(</mo><mn>9</mn><mo separator="true">,</mo><mn>14</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(A,B,C,D)=\sum m(4,8,10,11,12,15)+d(9,14)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mopen">(</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mclose">)</span></span></span></span> 其中d<sub>i</sub>表示无关项</p>
<ol>
<li>列出所有使得输出为1的最小项（此处把无关项也包含其中），将其序号转成二进制，根据二进制写法中1的个数分类。按升序填入表格中，</li>
</ol>
<p>![截屏2021-03-05 13.30.19](/Users/changhao/Desktop/permanent/myPage/images/截屏2021-03-05 13.30.19.png)</p>
<ol start="2">
<li>
<p>合并最小项，对所有相邻的组中最小项进行搜索、对比，若某两个最小项之间只有一个数位不对，则可以将这两个最小项合并，并用短横“-”代替这个数位。产生size2</p>
</li>
<li>
<p>继续合并，产生size4，直到无法产生更大的size为止</p>
</li>
<li>
<p>寻找最小覆盖，可以通过最小项为横坐标、本原蕴含项为列坐标列一个表格，发现只有4个最小项个字只被一个本原蕴含项蕴含，因此这三个蕴含项就是本原蕴含项，可以得到最终的化简结果=m(4,12)+m(8,9,10,11)+(10,11,14,15)</p>
</li>
</ol>
<p>![截屏2021-03-05 13.37.41](/Users/changhao/Desktop/permanent/myPage/images/截屏2021-03-05 13.37.41.png)</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>C</mi><mo>+</mo><mi>C</mi><mover accent="true"><mi>D</mi><mo stretchy="true">‾</mo></mover><mo>+</mo><mover accent="true"><mrow><mi>A</mi><mi>B</mi></mrow><mo stretchy="true">‾</mo></mover><mi>D</mi></mrow><annotation encoding="application/x-tex">F(A,B,C,D)=AC+C\overline{D}+\overline{AB}D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9666600000000001em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8833300000000001em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></p>
<p>卡诺图简便但不精准，且无法应用于高维</p>
<p>QM算法精准不简便，但是可以编程实现啊，比卡诺图要高。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://firemakerwillow.github.io/post/gai-lu-lun-2-bei-xie-si-ding-li/">
                  <h3 class="post-title">
                    【概率论 2】贝叶斯定理
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
